<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Build your Yoann</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@600;700;800;900&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<style>
  :root {
    --bg: #f0e6d8;
    --panel: #fff8f0;
    --border: #d4c4b0;
    --text: #3a2e22;
    --accent: #e85d3a;
    --green: #4caf50;
    --accent2: #f4a43a;
    --shadow: 0 2px 8px rgba(0,0,0,0.08);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    font-family: 'Nunito', sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }

  /* ===== SHARED ===== */
  .screen {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 12px; padding: 16px;
    background: var(--bg);
    z-index: 10;
  }
  .screen.hidden { display: none; }

  h1 { font-family: 'Fredoka One', cursive; font-size: 1.8rem; color: var(--accent); }
  h2 { font-family: 'Fredoka One', cursive; font-size: 1.5rem; color: var(--accent); }
  .sub { font-weight: 700; color: #8a7a6a; font-size: 0.85rem; text-align: center; line-height: 1.5; max-width: 420px; }

  .btn {
    padding: 10px 28px; border: none; border-radius: 12px;
    font-family: 'Nunito', sans-serif; font-weight: 900; font-size: 0.85rem;
    cursor: pointer; transition: all 0.15s; letter-spacing: 0.5px;
  }
  .btn:hover { transform: translateY(-1px); }
  .btn:active { transform: translateY(0); }
  .btn-primary { background: var(--accent); color: white; box-shadow: 0 3px 12px rgba(232,93,58,0.25); }
  .btn-ghost { background: white; color: var(--text); border: 2px solid var(--border); }
  .btn:disabled { opacity: 0.4; pointer-events: none; }
  .row { display: flex; gap: 8px; }

  /* Face canvas (used everywhere) */
  .face-canvas {
    width: 320px; aspect-ratio: 1/1;
    background: var(--panel);
    border: 3px solid var(--border);
    border-radius: 20px;
    position: relative; overflow: hidden;
    box-shadow: var(--shadow);
    flex-shrink: 0;
  }
  .face-canvas .part-img {
    position: absolute;
    transform: translate(-50%, -50%);
    pointer-events: none;
    -webkit-user-drag: none;
  }

  /* ===== MEMORIZE ===== */
  .timer-wrap {
    width: 280px; height: 6px; background: #e0d4c6;
    border-radius: 3px; overflow: hidden;
  }
  .timer-bar {
    height: 100%; background: var(--accent);
    border-radius: 3px; transition: width 0.1s linear;
  }
  .timer-bar.warn { background: #e53e3e; }

  .diff-btns { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
  .diff-btn {
    padding: 10px 20px; border: 3px solid var(--border); border-radius: 12px;
    background: var(--panel); font-family: 'Nunito', sans-serif;
    font-weight: 900; font-size: 0.82rem; color: var(--text);
    cursor: pointer; transition: all 0.2s; text-align: center;
  }
  .diff-btn:hover { border-color: var(--accent); transform: translateY(-2px); }
  .diff-btn small { display: block; font-size: 0.6rem; color: #a09080; margin-top: 1px; }

  /* ===== PLAY ===== */
  .play-layout {
    display: flex; flex-direction: column;
    align-items: center; gap: 10px;
    height: 100vh; padding: 14px 16px;
  }
  .play-header {
    display: flex; align-items: center; justify-content: space-between; width: 320px;
  }
  .play-canvas .part-img.draggable {
    pointer-events: auto; cursor: grab;
    transition: filter 0.15s;
  }
  .play-canvas .part-img.draggable:hover {
    filter: drop-shadow(0 0 6px rgba(232,93,58,0.5));
  }
  .play-canvas .part-img.dragging {
    cursor: grabbing;
    filter: drop-shadow(0 2px 10px rgba(0,0,0,0.3));
    z-index: 999 !important;
  }

  .tray {
    width: 320px; background: var(--panel);
    border: 3px solid var(--border); border-radius: 14px;
    padding: 8px 12px;
    display: flex; align-items: center; justify-content: center; gap: 10px;
    box-shadow: var(--shadow);
  }
  .tray-item {
    width: 65px; height: 50px; background: #f5ede3;
    border: 2px solid var(--border); border-radius: 10px;
    display: flex; align-items: center; justify-content: center;
    padding: 4px; cursor: grab; transition: all 0.15s;
    position: relative;
  }
  .tray-item:hover { border-color: var(--accent); transform: translateY(-2px); }
  .tray-item img { max-width: 100%; max-height: 100%; pointer-events: none; -webkit-user-drag: none; }
  .tray-item.placed { opacity: 0.2; pointer-events: none; border-style: dashed; }

  /* ===== SCORE ===== */
  .compare-row { display: flex; gap: 14px; }
  .compare-box { text-align: center; }
  .compare-box .lbl {
    font-weight: 800; font-size: 0.7rem; color: #a09080;
    text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;
  }
  .compare-face {
    width: 180px; aspect-ratio: 1/1;
    background: var(--panel); border: 3px solid var(--border);
    border-radius: 16px; position: relative; overflow: hidden;
    box-shadow: var(--shadow);
  }
  .compare-face .part-img {
    position: absolute; transform: translate(-50%, -50%);
    pointer-events: none; -webkit-user-drag: none;
  }
  .ghost-marker {
    position: absolute; transform: translate(-50%, -50%);
    pointer-events: none; opacity: 0.3;
    border: 2px dashed var(--green); border-radius: 6px;
  }
  .ghost-marker img {
    position: relative !important; transform: none !important;
    width: 100% !important; height: 100% !important;
    object-fit: contain;
  }

  .score-display { position: relative; width: 140px; height: 140px; }
  .score-ring { width: 100%; height: 100%; transform: rotate(-90deg); }
  .score-ring-bg { fill: none; stroke: #e0d4c6; stroke-width: 8; }
  .score-ring-fill {
    fill: none; stroke-width: 8; stroke-linecap: round;
    stroke-dasharray: 408; stroke-dashoffset: 408;
    transition: stroke-dashoffset 1.2s ease-out;
  }
  .ring-low { stroke: #e53e3e; }
  .ring-mid { stroke: var(--accent2); }
  .ring-high { stroke: var(--green); }
  .score-num {
    position: absolute; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    font-family: 'Fredoka One', cursive; font-size: 2.4rem;
  }
  .score-num small {
    font-family: 'Nunito', sans-serif; font-size: 0.65rem;
    font-weight: 800; color: #a09080; text-transform: uppercase;
  }
  .score-msg {
    font-family: 'Fredoka One', cursive; font-size: 1.1rem;
    color: var(--accent); text-align: center;
  }

  /* Loading screen */
  .loading {
    font-weight: 800; font-size: 0.9rem; color: #8a7a6a;
  }
</style>
</head>
<body>

<!-- ====== LOADING SCREEN ====== -->
<div class="screen" id="loadingScreen">
  <h1>Build your Yoann</h1>
  <p class="loading">Loading...</p>
</div>

<!-- ====== DIFFICULTY SCREEN ====== -->
<div class="screen hidden" id="diffScreen">
  <h2>Ready?</h2>
  <p class="sub">How long do you want to memorize the face?</p>
  <div class="diff-btns">
    <button class="diff-btn" onclick="startMemorize(5000, false)">Easy<small>5 sec</small></button>
    <button class="diff-btn" onclick="startMemorize(3000, false)">Medium<small>3 sec</small></button>
    <button class="diff-btn" onclick="startMemorize(1000, false)">Hard<small>1 sec</small></button>
    <button class="diff-btn" onclick="startMemorize(100, true)" style="border-color: #e53e3e; color: #e53e3e;">Extreme<small>0.1 sec ðŸ”¥</small></button>
  </div>
</div>

<!-- ====== MEMORIZE SCREEN ====== -->
<div class="screen hidden" id="memScreen">
  <h2>Memorize!</h2>
  <div class="timer-wrap"><div class="timer-bar" id="memBar"></div></div>
  <div class="face-canvas" id="memCanvas" style="width:300px;"></div>
</div>

<!-- ====== PLAY SCREEN ====== -->
<div class="screen hidden" id="playScreen">
  <div class="play-layout">
    <div class="play-header">
      <h2>Place the parts!</h2>
      <button class="btn btn-ghost" style="padding:6px 14px; font-size:0.75rem;" onclick="resetPlay()">â†© Reset</button>
    </div>
    <div class="face-canvas play-canvas" id="playCanvas"></div>

    <!-- Transform Controls (only visible in Extreme mode when part is selected) -->
    <div id="transformControls" style="display:none; width:320px; padding:8px 12px; background:var(--panel); border:2px solid var(--border); border-radius:12px; margin-top:4px;">
      <div style="font-size:0.7rem; font-weight:800; color:var(--accent); text-align:center; margin-bottom:6px;" id="selectedPartLabel"></div>
      <div style="display:flex; gap:12px; align-items:center;">
        <div style="flex:1;">
          <label style="font-size:0.65rem; font-weight:800; color:#8a7a6a; display:block; margin-bottom:2px;">Rotation</label>
          <input type="range" id="rotationSlider" min="-180" max="180" value="0" step="1"
                 oninput="adjustTransform()"
                 style="width:100%; accent-color:var(--accent);">
          <div style="font-size:0.6rem; color:#a09080; text-align:center;" id="rotationValue">0Â°</div>
        </div>
        <div style="flex:1;">
          <label style="font-size:0.65rem; font-weight:800; color:#8a7a6a; display:block; margin-bottom:2px;">Zoom</label>
          <input type="range" id="zoomSlider" min="50" max="150" value="100" step="1"
                 oninput="adjustTransform()"
                 style="width:100%; accent-color:var(--accent);">
          <div style="font-size:0.6rem; color:#a09080; text-align:center;" id="zoomValue">100%</div>
        </div>
      </div>
    </div>

    <div class="tray" id="tray"></div>
    <button class="btn btn-primary" id="doneBtn" onclick="submitAnswer()">âœ“ Done</button>
  </div>
</div>

<!-- ====== SCORE SCREEN ====== -->
<div class="screen hidden" id="scoreScreen">
  <h2>Results</h2>
  <div class="compare-row">
    <div class="compare-box">
      <div class="lbl">Target</div>
      <div class="compare-face" id="cmpTarget"></div>
    </div>
    <div class="compare-box">
      <div class="lbl">Yours</div>
      <div class="compare-face" id="cmpYours"></div>
    </div>
  </div>
  <div class="score-display">
    <svg class="score-ring" viewBox="0 0 140 140">
      <circle class="score-ring-bg" cx="70" cy="70" r="65"/>
      <circle class="score-ring-fill" id="scoreRing" cx="70" cy="70" r="65"/>
    </svg>
    <div class="score-num"><span id="scoreVal">0</span><small>score</small></div>
  </div>
  <div class="score-msg" id="scoreMsg"></div>
  <div class="row">
    <button class="btn btn-ghost" onclick="shareResults()">ðŸ“¸ Share</button>
    <button class="btn btn-primary" onclick="playAgain()">Play Again</button>
  </div>
</div>

<script>
// ============ CONFIG ============
const PART_KEYS = ['leftEye', 'rightEye', 'nose', 'mouth'];
const PART_LABELS = { leftEye:'Left Eye', rightEye:'Right Eye', nose:'Nose', mouth:'Mouth' };

// ============ HARDCODED CALIBRATION ============
const CALIBRATION = {
  "baseFaceNatW": 500,
  "parts": {
    "leftEye": {
      "x": 23.875,
      "y": 38,
      "w": 105
    },
    "rightEye": {
      "x": 69.875,
      "y": 30.1875,
      "w": 97
    },
    "nose": {
      "x": 49.0625,
      "y": 45.5625,
      "w": 99.84
    },
    "mouth": {
      "x": 52.8125,
      "y": 81.75,
      "w": 148
    }
  }
};

// ============ IMAGE PATHS ============
const IMAGE_PATHS = {
  original: 'yoann.png',
  base: 'base_face.png',
  leftEye: 'left_eye.png',
  rightEye: 'right_eye.png',
  nose: 'nose.png',
  mouth: 'mouth.png'
};

// ============ STATE ============
let parts = {}; // key -> { img:Image, dataUrl, x, y, w }
let playerPos = {}; // key -> { x, y, placed, userRotation, userScale }
let dragState = null;
let originalFaceUrl = null;
let baseFaceUrl = null;
let baseFaceNatW = CALIBRATION.baseFaceNatW;
let isExtremeMode = false; // Extreme difficulty flag
let partTransforms = {}; // key -> { rotation, scale } for extreme mode (random)
let selectedPart = null; // Currently selected part key for transform controls

// ============ INITIALIZATION ============
function init() {
  preloadImages();
}

function preloadImages() {
  let loaded = 0;
  const total = Object.keys(IMAGE_PATHS).length;

  const checkComplete = () => {
    loaded++;
    if (loaded === total) {
      setTimeout(() => show('diffScreen'), 300);
    }
  };

  // Load original face
  const originalImg = new Image();
  originalImg.onload = () => {
    originalFaceUrl = IMAGE_PATHS.original;
    checkComplete();
  };
  originalImg.onerror = () => {
    console.error('Failed to load original face:', IMAGE_PATHS.original);
    checkComplete();
  };
  originalImg.src = IMAGE_PATHS.original;

  // Load base face
  const baseImg = new Image();
  baseImg.onload = () => {
    baseFaceNatW = baseImg.naturalWidth;
    baseFaceUrl = IMAGE_PATHS.base;
    checkComplete();
  };
  baseImg.onerror = () => {
    console.error('Failed to load base face:', IMAGE_PATHS.base);
    checkComplete();
  };
  baseImg.src = IMAGE_PATHS.base;

  // Load parts
  PART_KEYS.forEach(key => {
    const img = new Image();
    img.onload = () => {
      parts[key] = {
        img: img,
        dataUrl: IMAGE_PATHS[key],
        x: CALIBRATION.parts[key].x,
        y: CALIBRATION.parts[key].y,
        w: CALIBRATION.parts[key].w
      };
      checkComplete();
    };
    img.onerror = () => {
      console.error('Failed to load part:', IMAGE_PATHS[key]);
      checkComplete();
    };
    img.src = IMAGE_PATHS[key];
  });
}

// ============ MEMORIZE ============
function startMemorize(ms, extreme = false) {
  isExtremeMode = extreme;
  show('memScreen');
  const canvas = document.getElementById('memCanvas');
  canvas.innerHTML = '';

  if (originalFaceUrl) {
    const img = document.createElement('img');
    img.src = originalFaceUrl;
    img.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;border-radius:17px;';
    canvas.appendChild(img);
  } else {
    renderFaceOn(canvas, parts, 300/320);
  }

  const bar = document.getElementById('memBar');
  bar.style.width = '100%';
  bar.classList.remove('warn');

  const t0 = Date.now();
  const tick = () => {
    const pct = Math.max(0, 1 - (Date.now()-t0)/ms) * 100;
    bar.style.width = pct + '%';
    if (pct < 25) bar.classList.add('warn');
    if (Date.now()-t0 < ms) requestAnimationFrame(tick);
    else startPlay();
  };
  requestAnimationFrame(tick);
}

// ============ PLAY ============
function startPlay() {
  show('playScreen');
  playerPos = {};
  selectedPart = null;

  // Hide/show controls based on mode
  const controls = document.getElementById('transformControls');
  controls.style.display = 'none';

  // Generate random transforms for extreme mode
  if (isExtremeMode) {
    PART_KEYS.forEach(k => {
      partTransforms[k] = {
        rotation: Math.random() * 360 - 180, // -180 to 180 degrees
        scale: 0.7 + Math.random() * 0.6     // 0.7 to 1.3x scale
      };
    });
  } else {
    partTransforms = {};
  }

  renderPlayCanvas();
  renderTray();
}

function renderPlayCanvas() {
  const canvas = document.getElementById('playCanvas');
  canvas.innerHTML = '';

  // Click on empty space to deselect
  canvas.onclick = () => {
    if (isExtremeMode) {
      selectedPart = null;
      document.getElementById('transformControls').style.display = 'none';
      renderPlayCanvas();
    }
  };

  if (baseFaceUrl) {
    const bg = document.createElement('img');
    bg.src = baseFaceUrl;
    bg.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;border-radius:17px;pointer-events:none;';
    canvas.appendChild(bg);
  }

  ['leftEye','rightEye','nose','mouth'].forEach((k, i) => {
    const pp = playerPos[k];
    if (!pp || !pp.placed) return;
    const p = parts[k];
    const el = document.createElement('img');
    el.src = p.dataUrl;
    el.className = 'part-img draggable';
    el.id = 'play_' + k;
    el.style.left = pp.x + '%';
    el.style.top = pp.y + '%';
    el.style.width = p.w + 'px';
    el.style.height = 'auto';
    el.style.zIndex = i + 5;

    // Apply transforms
    let transform = 'translate(-50%, -50%)';
    if (isExtremeMode && partTransforms[k]) {
      const t = partTransforms[k];
      const userRot = pp.userRotation || 0;
      const userScale = pp.userScale || 1;
      const finalRot = t.rotation + userRot;
      const finalScale = t.scale * userScale;
      transform += ` rotate(${finalRot}deg) scale(${finalScale})`;
    }
    el.style.transform = transform;

    // Highlight if selected
    if (selectedPart === k) {
      el.style.outline = '3px solid var(--accent)';
      el.style.outlineOffset = '2px';
    }

    el.addEventListener('mousedown', e => playDragStart(e, k));
    el.addEventListener('touchstart', e => playDragStart(e, k));
    el.addEventListener('click', e => { e.stopPropagation(); if (isExtremeMode) selectPart(k); });
    canvas.appendChild(el);
  });
}

function selectPart(key) {
  if (!isExtremeMode) return;

  selectedPart = key;
  const pp = playerPos[key];

  // Show controls
  const controls = document.getElementById('transformControls');
  controls.style.display = 'block';

  // Update label
  document.getElementById('selectedPartLabel').textContent = PART_LABELS[key];

  // Set slider values
  const userRot = pp.userRotation || 0;
  const userScale = pp.userScale || 1;

  document.getElementById('rotationSlider').value = userRot;
  document.getElementById('rotationValue').textContent = Math.round(userRot) + 'Â°';

  document.getElementById('zoomSlider').value = Math.round(userScale * 100);
  document.getElementById('zoomValue').textContent = Math.round(userScale * 100) + '%';

  renderPlayCanvas();
}

function adjustTransform() {
  if (!selectedPart || !playerPos[selectedPart]) return;

  const rotation = parseFloat(document.getElementById('rotationSlider').value);
  const zoom = parseFloat(document.getElementById('zoomSlider').value) / 100;

  playerPos[selectedPart].userRotation = rotation;
  playerPos[selectedPart].userScale = zoom;

  // Update display values
  document.getElementById('rotationValue').textContent = Math.round(rotation) + 'Â°';
  document.getElementById('zoomValue').textContent = Math.round(zoom * 100) + '%';

  renderPlayCanvas();
}

function renderTray() {
  const tray = document.getElementById('tray');
  const keys = ['leftEye','rightEye','nose','mouth'];
  tray.innerHTML = keys.map(k => {
    const p = parts[k];
    if (!p) return '';
    const placed = playerPos[k]?.placed;

    // Apply random transforms in extreme mode
    let imgStyle = '';
    if (isExtremeMode && partTransforms[k]) {
      const t = partTransforms[k];
      imgStyle = `style="transform: rotate(${t.rotation}deg) scale(${t.scale});"`;
    }

    return `<div class="tray-item ${placed?'placed':''}" data-key="${k}"
                 onmousedown="trayDragStart(event,'${k}')"
                 ontouchstart="trayDragStart(event,'${k}')">
      <img src="${p.dataUrl}" ${imgStyle}>
    </div>`;
  }).join('');
}

function trayDragStart(e, key) {
  if (playerPos[key]?.placed) return;
  e.preventDefault();
  const p = parts[key];
  const cx = e.touches ? e.touches[0].clientX : e.clientX;
  const cy = e.touches ? e.touches[0].clientY : e.clientY;

  const ghost = document.createElement('img');
  ghost.src = p.dataUrl;
  ghost.style.cssText = `position:fixed;pointer-events:none;z-index:9999;width:${p.w}px;height:auto;opacity:0.8;filter:drop-shadow(0 3px 8px rgba(0,0,0,0.2));`;
  ghost.style.left = (cx - p.w/2) + 'px';
  ghost.style.top = (cy - 20) + 'px';

  // Apply transforms in extreme mode
  if (isExtremeMode && partTransforms[key]) {
    const t = partTransforms[key];
    ghost.style.transform = `rotate(${t.rotation}deg) scale(${t.scale})`;
  }

  document.body.appendChild(ghost);

  dragState = { ctx:'tray', key, ghost, w:p.w };
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchmove', onDrag, {passive:false});
  document.addEventListener('touchend', endDrag);
}

function playDragStart(e, key) {
  e.preventDefault(); e.stopPropagation();
  const el = document.getElementById('play_' + key);
  el.classList.add('dragging');
  const cr = document.getElementById('playCanvas').getBoundingClientRect();
  const cx = e.touches ? e.touches[0].clientX : e.clientX;
  const cy = e.touches ? e.touches[0].clientY : e.clientY;

  dragState = { ctx:'playMove', key, el, sx:cx, sy:cy, ox:playerPos[key].x, oy:playerPos[key].y, cr };
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchmove', onDrag, {passive:false});
  document.addEventListener('touchend', endDrag);
}

// ============ SHARED DRAG ============
function onDrag(e) {
  if (!dragState) return;
  e.preventDefault();
  const cx = e.touches ? e.touches[0].clientX : e.clientX;
  const cy = e.touches ? e.touches[0].clientY : e.clientY;

  if (dragState.ctx === 'playMove') {
    const dx = cx - dragState.sx, dy = cy - dragState.sy;
    const nl = dragState.ox + (dx/dragState.cr.width)*100;
    const nt = dragState.oy + (dy/dragState.cr.height)*100;
    dragState.el.style.left = nl + '%';
    dragState.el.style.top = nt + '%';
  } else if (dragState.ctx === 'tray') {
    dragState.ghost.style.left = (cx - dragState.w/2) + 'px';
    dragState.ghost.style.top = (cy - 20) + 'px';
  }
}

function endDrag(e) {
  if (!dragState) return;
  const cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
  const cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

  if (dragState.ctx === 'tray') {
    dragState.ghost.remove();
    const cr = document.getElementById('playCanvas').getBoundingClientRect();
    if (cx >= cr.left && cx <= cr.right && cy >= cr.top && cy <= cr.bottom) {
      const xp = ((cx-cr.left)/cr.width)*100;
      const yp = ((cy-cr.top)/cr.height)*100;
      playerPos[dragState.key] = { x:xp, y:yp, placed:true, userRotation:0, userScale:1 };
      renderPlayCanvas();
      renderTray();

      // Auto-select in extreme mode for easy adjustment
      if (isExtremeMode) {
        selectPart(dragState.key);
      }
    }
  } else if (dragState.ctx === 'playMove') {
    dragState.el.classList.remove('dragging');
    const dx = cx - dragState.sx, dy = cy - dragState.sy;
    playerPos[dragState.key].x = dragState.ox + (dx/dragState.cr.width)*100;
    playerPos[dragState.key].y = dragState.oy + (dy/dragState.cr.height)*100;
  }

  document.removeEventListener('mousemove', onDrag);
  document.removeEventListener('mouseup', endDrag);
  document.removeEventListener('touchmove', onDrag);
  document.removeEventListener('touchend', endDrag);
  dragState = null;
}

function resetPlay() {
  playerPos = {};
  selectedPart = null;
  document.getElementById('transformControls').style.display = 'none';
  renderPlayCanvas();
  renderTray();
}

// ============ SCORING ============
function submitAnswer() {
  const keys = ['leftEye','rightEye','nose','mouth'];
  const allPlaced = keys.every(k => playerPos[k]?.placed);
  if (!allPlaced) {
    document.querySelectorAll('.tray-item:not(.placed)').forEach(el => {
      el.style.borderColor = '#e53e3e';
      setTimeout(() => el.style.borderColor = '', 500);
    });
    return;
  }

  let totalDist = 0;
  keys.forEach(k => {
    const t = parts[k], p = playerPos[k];
    totalDist += Math.sqrt((t.x-p.x)**2 + (t.y-p.y)**2);
  });
  const avg = totalDist / keys.length;
  const score = Math.max(0, Math.min(100, Math.round(100 - (avg/30)*100)));

  showScoreScreen(score);
}

function showScoreScreen(score) {
  show('scoreScreen');
  const scale = 180/320;

  // Target
  const tc = document.getElementById('cmpTarget');
  tc.innerHTML = '';
  if (originalFaceUrl) {
    const img = document.createElement('img');
    img.src = originalFaceUrl;
    img.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;border-radius:13px;transform:none;';
    tc.appendChild(img);
  } else {
    renderFaceOn(tc, parts, scale);
  }

  // Yours
  const yc = document.getElementById('cmpYours');
  yc.innerHTML = '';
  if (baseFaceUrl) {
    const bg = document.createElement('img');
    bg.src = baseFaceUrl;
    bg.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover;border-radius:13px;transform:none;';
    yc.appendChild(bg);
  }
  ['leftEye','rightEye','nose','mouth'].forEach((k,i) => {
    const t = parts[k], pp = playerPos[k];
    if (pp?.placed) {
      const el = document.createElement('img');
      el.src = t.dataUrl;
      el.className = 'part-img';
      let transform = 'translate(-50%, -50%)';

      // Apply transforms in extreme mode
      if (isExtremeMode && partTransforms[k]) {
        const tf = partTransforms[k];
        const userRot = pp.userRotation || 0;
        const userScale = pp.userScale || 1;
        const finalRot = tf.rotation + userRot;
        const finalScale = tf.scale * userScale;
        transform += ` rotate(${finalRot}deg) scale(${finalScale})`;
      }

      el.style.cssText = `left:${pp.x}%;top:${pp.y}%;width:${t.w*scale}px;height:auto;z-index:${i+5};transform:${transform};`;
      yc.appendChild(el);
    }
    const g = document.createElement('div');
    g.className = 'ghost-marker';
    g.style.cssText = `left:${t.x}%;top:${t.y}%;width:${t.w*scale}px;`;
    const gi = document.createElement('img');
    gi.src = t.dataUrl;
    g.appendChild(gi);
    yc.appendChild(g);
  });

  // Animate ring
  const ring = document.getElementById('scoreRing');
  ring.className = 'score-ring-fill ' + (score<40?'ring-low':score<70?'ring-mid':'ring-high');
  ring.style.strokeDashoffset = '408';
  requestAnimationFrame(() => { ring.style.strokeDashoffset = 408 - (408*score/100); });

  const val = document.getElementById('scoreVal');
  val.textContent = '0';
  let cur = 0;
  const step = () => {
    cur = Math.min(cur+2, score);
    val.textContent = cur;
    if (cur < score) requestAnimationFrame(step);
  };
  setTimeout(step, 200);

  const msgs = score>=90 ? ['Perfect! ðŸŽ¯','Spot on! ðŸŒŸ','Incredible! âœ¨']
    : score>=70 ? ['Great job! ðŸ‘','Nice memory! ðŸ§ ','Well done! ðŸ’ª']
    : score>=50 ? ['Not bad! ðŸ‘','Getting there! ðŸ“ˆ']
    : ['Tricky! ðŸ¤”','Keep practicing! ðŸ’­'];
  document.getElementById('scoreMsg').textContent = msgs[Math.floor(Math.random()*msgs.length)];
}

function playAgain() {
  show('diffScreen');
}

async function shareResults() {
  const scoreScreen = document.getElementById('scoreScreen');

  // Temporarily style for better screenshot
  const originalBg = scoreScreen.style.background;
  scoreScreen.style.background = 'var(--bg)';

  try {
    // Capture the score screen
    const canvas = await html2canvas(scoreScreen, {
      backgroundColor: '#f0e6d8',
      scale: 2, // Higher quality
      logging: false,
      useCORS: true
    });

    // Convert to blob
    canvas.toBlob(async (blob) => {
      const file = new File([blob], 'face-builder-score.png', { type: 'image/png' });

      // Try Web Share API first (mobile-friendly)
      if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            title: 'Face Builder Game - My Score',
            text: `I scored ${document.getElementById('scoreVal').textContent} in Face Builder! Can you beat it?`,
            files: [file]
          });
          console.log('Shared successfully');
        } catch (err) {
          if (err.name !== 'AbortError') {
            // User cancelled, fallback to download
            downloadImage(blob);
          }
        }
      } else {
        // Fallback: Download the image
        downloadImage(blob);
      }
    }, 'image/png');

  } catch (error) {
    console.error('Screenshot failed:', error);
    alert('Failed to generate screenshot. Please try again.');
  } finally {
    // Restore original background
    scoreScreen.style.background = originalBg;
  }
}

function downloadImage(blob) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `face-builder-score-${Date.now()}.png`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  // Show feedback
  const btn = event.target;
  const originalText = btn.textContent;
  btn.textContent = 'âœ“ Downloaded!';
  btn.disabled = true;
  setTimeout(() => {
    btn.textContent = originalText;
    btn.disabled = false;
  }, 2000);
}

// ============ UTILS ============
function renderFaceOn(canvas, data, scale) {
  const order = ['leftEye','rightEye','nose','mouth'];
  order.forEach((k,i) => {
    const p = data[k];
    if (!p) return;
    const el = document.createElement('img');
    el.src = p.dataUrl;
    el.className = 'part-img';
    el.style.cssText = `left:${p.x}%;top:${p.y}%;width:${p.w * scale}px;height:auto;z-index:${i+1};`;
    canvas.appendChild(el);
  });
}

function show(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
  document.getElementById(id).classList.remove('hidden');
}

// Boot
init();
</script>
</body>
</html>
